---
title: Widget injection
---

The widget injection system lets modules drop extra UI into shared surfaces without forking core code. Widgets declare themselves once, map to one or more slots, and hosts choose how to render them (stacked, grouped cards, or as tabs).

## Slot types and placement hints

- **Stacked (`kind: 'stack'`)** – renders inline where the slot is placed. Default when no `kind` is provided.
- **Grouped (`kind: 'group'`)** – Crud forms add a new group card using `groupLabel`, `groupDescription`, and optional `column`.
- **Tabbed (`kind: 'tab'`)** – hosts with tabs add a new tab using `groupLabel` as the tab title.
- Extra metadata: `priority` (higher first), `groupId` (stable id), `groupDescription`, `column` (1 | 2).

Define entries in your module’s `widgets/injection-table.ts`:

```ts
import type { ModuleInjectionTable } from '@open-mercato/shared/modules/widgets/injection'

export const injectionTable: ModuleInjectionTable = {
  'sales.document.detail.quote:tabs': [
    { widgetId: 'example.injection.sales-todos', kind: 'tab', groupLabel: 'Todos (example)' },
  ],
  'crud-form:catalog.product': 'example.injection.crud-validation',
}
```

## Available slots

- **CrudForm** – whichever spot id you pass to `CrudForm` (`injectionSpotId`). If omitted, it auto-derives `crud-form:<entityId>` (colon → dot) from the first `entityId`, so most forms pick up widgets by entity. Widgets with `kind: 'group'` render as new groups; others stack above the form. Helpers: `generateCrudFormInjectionSpotId()` and `CrudFormInjectionSpots` from `@open-mercato/ui/backend/injection/helpers`.
- **DataTable** – `data-table:<tableId>:header` and `data-table:<tableId>:footer` (auto when `perspective.tableId` is set; or pass `injectionSpotId`).
- **Dashboard** – `dashboard:before` and `dashboard:after` wrap the widget grid.
- **Sales documents** – `sales.document.detail.quote:tabs`, `sales.document.detail.order:tabs` (new tabs) and `sales.document.detail.<kind>:details` for blocks beneath the details section.
- **Customers** – `customers.company.detail:tabs` and `customers.company.detail:details`; `customers.person.detail:tabs` and `customers.person.detail:details`.
- **Admin layout** – `admin.page:<normalized-path>:before` / `after` wraps every backend page (path is lowercased, stripped of query, `/` → `:`).

## Example: Sales todos tab (example module)

The example module now ships `example.injection.sales-todos`, mapped to both sales quote and order tab slots:

```ts
// packages/example/src/modules/example/widgets/injection-table.ts
export const injectionTable = {
  'sales.document.detail.quote:tabs': [
    { widgetId: 'example.injection.sales-todos', kind: 'tab', groupLabel: 'Todos (example)', priority: -10 },
  ],
  'sales.document.detail.order:tabs': [
    { widgetId: 'example.injection.sales-todos', kind: 'tab', groupLabel: 'Todos (example)', priority: -10 },
  ],
}
```

The widget itself is a client component that uses `InjectionWidgetComponentProps` and the shared `apiCall` helper to list, add, and toggle todos. It renders an info banner with a link back to this page so downstream modules can copy the pattern.

## Authoring widgets

1. Create a widget module exporting `InjectionWidgetModule` with metadata (`id`, `title`, optional `features`).
2. Build the client component using `InjectionWidgetComponentProps<TContext, TData>`.
3. Add entries to `widgets/injection-table.ts` with placement hints.
4. Run `yarn modules:prepare` (or `yarn mercato generate registry`) to regenerate registries.

The injection system supports multiple widgets per slot across modules; they are ordered by `priority` (higher first). Event hooks (`onLoad`, `onBeforeSave`, `onSave`, `onAfterSave`) remain available and are triggered once per widget.
