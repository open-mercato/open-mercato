---
title: Decyzje (EZD → OpenMercato)
sidebar_position: 90
---

Ten dokument zbiera decyzje projektowe związane z mapowaniem kancelaryjno‑archiwalnym na OpenMercato.

Format decyzji (ADR‑like):

- Id: `D-XXX`
- Kontekst
- Decyzja
- Konsekwencje
- Status: proposed/accepted/superseded

## D-001: MVP ograniczone do CRUD

- Status: accepted
- Kontekst: chcemy szybko zmapować model danych i API.
- Decyzja: na start budujemy tylko CRUD + walidacje + OpenAPI.
- Konsekwencje: procesy/workflow będą opisywane, ale wdrażane później.

## D-002: RPW jako numeracja/widok

- Status: accepted
- Kontekst: RPW jest rejestrem przesyłek wpływających.
- Decyzja: RPW nie jest osobną encją – to numeracja + widoki na przesyłkach.
- Konsekwencje: pola RPW lądują na encji przesyłki; raporty/listy budujemy query.

## D-003: Koszulka → Sprawa 1:1

- Status: superseded (by D-009)
- Kontekst: pierwotnie zakładaliśmy „koszulkę” jako obiekt przejściowy przed sprawą.
- Decyzja: (nieaktualne) koszulka jest encją i może zostać przekształcona w sprawę 1:1.
- Konsekwencje: (nieaktualne) pola wiążące typu `folder.caseId` / `case.folderId`.

## D-009: Ujednolicenie Sprawa = Koszulka

- Status: accepted
- Kontekst:
- Analiza wymagań wykazała, że "Koszulka" i "Sprawa" są konceptualnie tym samym obiektem.
- "Sprawa" to "Koszulka" z przypisanym znakiem sprawy.
- Utrzymywanie dwóch osobnych encji prowadziło do nadmiernej złożoności i niespójności w dokumentacji.
- Decyzja:
- Sprawa i Koszulka są tą samą encją (`records.cases`).
- Pole `sign` (znak sprawy) jest opcjonalne:
- Gdy `sign` jest wypełniony → rekord funkcjonuje jako pełna "Sprawa"
- Gdy `sign` jest pusty → rekord funkcjonuje jako "Koszulka" (kontener roboczy/teczka tematyczna)
- Usuwamy osobną encję `records.folders`.
- Konsekwencje:
- Uproszczenie modelu danych (7 encji zamiast 8).
- Dokumenty powiązane są tylko z `caseId` (nie `folderId`).
- Powiązania między rekordami (`record_links`) używają tylko typu `case`.
- Wszystkie referencje do "Koszulki" w dokumentacji są aktualizowane, aby odzwierciedlać ten ujednolicony model.
- CRUD dla sprawy obsługuje zarówno rekordy z przypisanym znakiem sprawy, jak i bez niego.

## D-007: Powiązania neutralne + read-only (Sprawa)

- Status: accepted (aktualizowane przez D-009)
- Kontekst:
	- W źródłach pojawia się potrzeba „wzajemnie powiązanych spraw”.
	- Sprawy i koszulki służą katalogowaniu informacji i wymagają elastycznego łączenia.
	- Potrzebujemy możliwości „zamknięcia” obiektu (blokady zmian) oraz późniejszego otwarcia.
- Decyzja:
	- Sprawy i koszulki są osobnymi obiektami domenowymi i encjami (MVP).
	- Powiązania między obiektami są **neutralne** (bez typu/etykiety) i **symetryczne**.
		- Dopuszczamy: sprawa↔sprawa, koszulka↔koszulka, sprawa↔koszulka.
	- Wprowadzamy stan **read-only** (zamknięcie) dla spraw i koszulek.
		- Read-only blokuje: edycję pól, dopinanie/odpinanie dokumentów, dodawanie/usuwanie powiązań.
		- Read-only jest **odwracalne** (reopen), ale wymaga dedykowanego uprawnienia (RBAC) — nazwa do ustalenia w module `records`.
	- Dokument może być przypięty do **dokładnie jednego** obiektu: sprawy *albo* koszulki (lub do żadnego).
- Konsekwencje:
	- Usuwamy koncepcję „koszulka → sprawa 1:1” i wynikające z niej pola/endpointy.
	- Dodajemy encję/zasób powiązań (roboczo: `records.record_links`) oraz reguły unikalności par.
	- W CRUD dla spraw/koszulek musimy walidować blokady read-only.

## D-004: Dokument może istnieć bez przesyłki

- Status: accepted
- Kontekst: dokument może zostać „przyniesiony”.
- Decyzja: `document.incomingShipmentId` jest opcjonalne.
- Konsekwencje: walidacje nie mogą wymagać przesyłki.

## D-005: Skład chronologiczny – lokalizacja jako encja z historią

- Status: accepted
- Kontekst: lokalizacja ma być śledzona w czasie.
- Decyzja: modelujemy lokalizacje oraz historię przypisań (bez nadpisywania).
- Konsekwencje: potrzebny jest dodatkowy zasób „history/assignments”.

## D-006: Wyszukiwanie MVP = tokens dla Spraw i Dokumentów

- Status: accepted
- Kontekst: chcemy, aby użytkownik mógł szybko znajdować rekordy Cmd+K, ale bez wdrażania fulltext/vector w MVP.
- Decyzja:
	- W MVP indeksujemy i wystawiamy w Cmd+K tylko: **Sprawa** (obejmuje rekordy z i bez znaku sprawy) i **Dokument**.
	- Strategia search na start: **tokens**.
- Konsekwencje:
	- CRUD dla tych encji musi odświeżać `query_index`.
	- Moduł `records` musi dostarczyć presenter (`formatResult`) dla tokens, żeby wyniki były czytelne.

## D-008: Dokument jako załącznik z metadanymi

- Status: accepted
- Kontekst:
	- Dokumenty w systemie EZD są nośnikami treści, które mogą mieć różne formy (elektroniczne pliki, skany papierowych dokumentów).
	- Potrzebujemy spójnego podejścia do przechowywania i zarządzania plikami w systemie.
	- OpenMercato posiada moduł `attachments` (core) do zarządzania plikami.
- Decyzja:
	- **Dokument** (encja `records.documents`) jest konceptualnie **załącznikiem z metadanymi**.
	- Dokument wykorzystuje moduł `attachments` do przechowywania plików.
	- Relacja: każdy rekord dokumentu może mieć powiązane załączniki (pliki) poprzez `attachmentId` lub wielokrotne załączniki.
	- Metadane dokumentu (tytuł, rodzaj, poziom dostępu, daty, powiązania) są przechowywane w encji `records.documents`.
	- Fizyczne pliki są zarządzane przez moduł `attachments`.
- Konsekwencje:
	- Encja `records.documents` zawiera pola metadanych oraz referencje do załączników (`attachmentIds` lub podobne).
	- RBAC dla dokumentów musi uwzględniać zasady dostępu do załączników.
	- Główny właściciel załącznika (primary owner) jest określany przez powiązanie dokumentu:
		- Jeśli dokument ma `incomingShipmentId` → właścicielem jest przesyłka.
		- Jeśli dokument ma `caseId` → właścicielem jest sprawa (niezależnie od tego, czy ma przypisany znak sprawy).
		- Jeśli dokument nie ma żadnego powiązania → właścicielem jest sam dokument.
	- API dokumentów musi obsługiwać upload/download plików przez moduł `attachments`.
	- Przy usuwaniu dokumentu należy rozważyć politykę usuwania powiązanych załączników (cascade delete lub orphan handling).


## D-010: Kancelaria jako komórka organizacyjna (bez encji `records.offices`)

- Status: accepted
- Kontekst:
  - System musi obsługiwać wiele kancelarii/sekretariatów w ramach jednej organizacji.
  - Kancelaria jest elementem struktury organizacyjnej, do której są przypisani użytkownicy.
- Decyzja:
  - **Kancelaria** jest reprezentowana jako komórka organizacyjna w `directory.organizations`.
  - Nie wprowadzamy osobnej encji `records.offices`.
  - Przesyłka wpływająca przechowuje wskazanie kancelarii przez `receivingOrgUnitId`.
- Konsekwencje:
  - RBAC: użytkownik ma dostęp tylko do przesyłek w scope komórek organizacyjnych, do których jest przypisany.
  - Numeracja RPW/RKW i uprawnienia bazują na strukturze organizacyjnej (bez CRUD dla kancelarii w `records`).

## D-011: RPW wykorzystuje wzorzec numeracji z OpenMercato

- Status: accepted
- Kontekst:
  - System OpenMercato posiada sprawdzony mechanizm numeracji dokumentów (`salesDocumentNumberGenerator`).
  - Mechanizm ten obsługuje: sekwencje bazodanowe, atomic increment, formaty konfigurowalne, concurrency.
  - RPW wymaga analogicznej funkcjonalności: automatyczna numeracja, chronologiczność, unikalność.
- Decyzja:
  - **RPW wykorzystuje wzorzec numeracji analogiczny do `salesDocumentNumberGenerator`**.
  - Zakres numeracji: `organizationId` + `tenantId` + `documentKind`, gdzie `documentKind = rpw:${yyyy}` (rocznie).
  - Format numeru jest narzucony: `RPW/{kanc_id}/{seq:5}/{yyyy}`.
  - Implementacja: tabela `incoming_shipment_sequences` z atomic increment.
  - Numer RPW jest nadawany wyłącznie w osobnej akcji „Zarejestruj wpływ”.
- Konsekwencje:
  - Reuse sprawdzonego wzorca – mniejsze ryzyko błędów, spójność z resztą systemu.
  - Łatwiejsza implementacja – można wykorzystać kod z `salesDocumentNumberGenerator` jako punkt startowy.
  - Niezmienność numeru: po rejestracji RPW nie podlega edycji.
  - Opcjonalnie: endpoint diagnostyczny dla administratorów: podgląd/ustawienie następnego numeru.

## D-012: Strony (Case Parties) jako encja w MVP

- Status: accepted
- Kontekst:
  - Sprawy w systemie EZD często wymagają identyfikacji podmiotów zaangażowanych (wnioskodawcy, uczestnicy, strony postępowania).
  - Podmioty mogą być zarejestrowane w systemie (moduł `customers`) lub ad-hoc (tylko nazwa).
  - Potrzebna jest elastyczność: jedna sprawa może mieć wiele stron w różnych rolach.
- Decyzja:
  - **Strony (Case Parties)** są osobną encją (`records.case_parties`) powiązaną ze sprawą.
  - Każda strona ma:
    - `caseId` (wymagane) – sprawa, do której należy
    - `role` (wymagane) – rola w sprawie (wnioskodawca, uczestnik, obserwator, strona postępowania)
    - `partyId` (opcjonalne) – referencja do podmiotu w rejestrze (np. `customers`)
    - `partyDisplayName` (wymagane, jeśli brak `partyId`) – nazwa podmiotu ad-hoc
    - Dane kontaktowe i adres (opcjonalne)
  - Strony podlegają read-only sprawy: jeśli sprawa jest zamknięta, strony nie mogą być modyfikowane.
  - Historia zmian stron jest zachowana (audit log).
- Konsekwencje:
  - Encja `records.case_parties` z relacją N:1 do sprawy.
  - CRUD: `/api/records/case-parties` z walidacją read-only sprawy.
  - RBAC: dostęp do stron przez uprawnienia do sprawy.
  - MVP: minimalny zestaw ról (wnioskodawca, uczestnik, obserwator, strona postępowania).
  - Przyszłość: możliwość "materializacji" strony ad-hoc jako pełnego podmiotu w rejestrze.

## D-013: Szablony spraw zamiast dziedzin

- Status: accepted
- Kontekst:
  - System musi obsługiwać różne typy spraw z różnymi strukturami danych i wymaganiami.
  - Wcześniejsza koncepcja "dziedziny" (domain) była zbyt sztywna – wymagała zmian w kodzie przy dodawaniu nowych typów.
  - Różne organizacje i jednostki mogą mieć różne potrzeby co do struktury spraw.
  - Custom fields w OpenMercato umożliwiają dynamiczną konfigurację pól, ale brakuje mechanizmu grupowania i standaryzacji per typ sprawy.
- Decyzja:
  - Wprowadzamy **Szablon sprawy** (`records.case_templates`) jako encję w MVP.
  - Szablon definiuje:
    - Strukturę pól dodatkowych (custom fields definition)
    - Wymagane i opcjonalne pola
    - Domyślne wartości
    - Sugerowaną klasę JRWA
    - Role stron sprawy
    - Konfigurację UI (kolejność, grupowanie, widoczność pól)
  - Sprawa może być utworzona na podstawie szablonu (`case.caseTemplateId` opcjonalne).
  - Szablony są wersjonowane – zmiana szablonu nie wpływa na istniejące sprawy.
  - Szablony zastępują koncepcję "dziedziny" – zamiast statycznego podziału mamy dynamiczny, konfigurowalny mechanizm.
- Konsekwencje:
  - Encja `records.case_templates` z polami: `code`, `name`, `description`, `customFieldsDefinition`, `defaultJrwaClassId`, `partyRoles`, `fieldOrder`, `isActive`.
  - CRUD dla szablonów: `/api/records/case-templates` (tylko administratorzy).
  - Przy tworzeniu sprawy: opcjonalny parametr `caseTemplateId` – jeśli podany, system aplikuje definicję z szablonu.
  - UI tworzenia sprawy: wybór szablonu z listy aktywnych szablonów, dynamiczne generowanie formularza na podstawie definicji.
  - Raportowanie: możliwość filtrowania i grupowania spraw według `caseTemplateId`.
  - Migracja z "dziedziny": istniejące "dziedziny" mogą być przekształcone w szablony podczas wdrożenia.
  - Większa elastyczność: administratorzy mogą tworzyć i modyfikować szablony bez angażowania developerów.
