---
title: Catalog
description: Command payloads for managing catalog products, variants, options, and pricing.
---

import OpenApiExplorerBanner from '@site/src/components/OpenApiExplorerBanner';

<OpenApiExplorerBanner />

The catalog module exposes both command handlers and REST endpoints (see `/api/catalog/products`, `/api/catalog/attribute-schemas`, `/api/catalog/variants`, `/api/catalog/options`, and `/api/catalog/prices`). The commands documented below remain the source of truth for validations and undo metadata, so you can safely script imports, seed data, or build bespoke HTTP wrappers even as new HTTP routes come online.

## Running catalog commands

```ts
import { createRequestContainer } from '@/lib/di/container'
import type { CommandBus } from '@open-mercato/shared/lib/commands'

const container = await createRequestContainer()
const commandBus = container.resolve<CommandBus>('commandBus')

await commandBus.execute('catalog.products.create', {
  input: {
    organizationId,
    tenantId,
    name: 'Starter T-Shirt',
    code: 'tee-basic',
    primaryCurrencyCode: 'USD',
    metadata: { category: 'apparel' },
    customFields: { material: 'cotton' }
  },
  ctx: { auth, container }
})
```

- Every command enforces tenant and organization scope via `ensureTenantScope`/`ensureOrganizationScope` (`packages/core/src/modules/catalog/commands/shared.ts:42`).
- Custom fields can be supplied either as `customFields` object or prefixed keys (`cf_color`); handlers call `parseWithCustomFields` and `setCustomFieldsIfAny` to persist values (`packages/core/src/modules/catalog/commands/products.ts:100`).
- Undo metadata is logged automatically; the audit log payload includes before/after snapshots for δ previews and rollbacks.

## Product commands — `catalog.products.*`

Handlers live in `packages/core/src/modules/catalog/commands/products.ts`.

| Command id | Purpose | Schema |
| --- | --- | --- |
| `catalog.products.create` | Create a product master record | `productCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:18`) |
| `catalog.products.update` | Patch an existing product (only provided keys are updated) | `productUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:32`) |
| `catalog.products.delete` | Soft delete a product once variants/prices are cleaned up | n/a (requires `before.id` in the undo snapshot) |

Key fields from `productCreateSchema`:

- `organizationId`, `tenantId` — required scope identifiers.
- `name` (string, ≤255), optional `description`.
- Optional catalog metadata: `code` (lowercase slug), `statusEntryId`, `primaryCurrencyCode`, `defaultUnit`, `attributeSchemaId` reference, `attributeSchema` JSON override, `attributeValues` map, and `offers` (array of `{ channelId, title, description }`) that bind products to sales channels. When `attributeSchemaId` is provided, the product inherits a shared schema template; providing `attributeSchema` in the same payload overwrites individual fields for that single product without mutating the shared template.
- Flags: `isConfigurable`, `isActive`, plus arbitrary `metadata` JSON.

Example payload:

```json
{
  "organizationId": "3d552375-7813-4e9d-8807-0283c907a9f9",
  "tenantId": "a2c6e50e-a6ef-4c7a-afe4-7b6f1998b5c2",
  "name": "Starter T-Shirt",
  "code": "tee-basic",
  "primaryCurrencyCode": "USD",
  "attributeSchemaId": "edc95a4d-9fb9-4cbc-b8ce-1b93af2c8e83",
  "attributeSchema": {
    "definitions": [
      { "key": "material", "label": "Material", "kind": "text" }
    ]
  },
  "offers": [
    { "channelId": "bf5efc35-c493-44e4-9307-5f50331a7405", "title": "Online store" }
  ],
  "isConfigurable": true,
  "metadata": { "category": "apparel" },
  "customFields": { "material": "cotton" }
}
```

## Variant commands — `catalog.variants.*`

Defined in `packages/core/src/modules/catalog/commands/variants.ts`.

| Command id | Purpose | Schema |
| --- | --- | --- |
| `catalog.variants.create` | Create a SKU tied to a product | `variantCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:39`) |
| `catalog.variants.update` | Patch variant attributes, dimensions, or option selections | `variantUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:65`) |
| `catalog.variants.delete` | Remove a variant after ensuring there are no prices or option links | n/a (id provided through undo payload) |

Highlights from `variantCreateSchema`:

- Required: `organizationId`, `tenantId`, `productId`.
- Optional: `name`, `sku`, `barcode`, `statusEntryId`, `isDefault`, `isActive`.
- Dimensions and weight via nested objects (`dimensions.width/height/depth/unit`, `weightValue`, `weightUnit`).
- `optionConfiguration` array linking option ids to option value selections.

## Option & option value commands — `catalog.options.*`

Both option and option value handlers are colocated in `packages/core/src/modules/catalog/commands/options.ts`.

| Command id | Purpose | Schema |
| --- | --- | --- |
| `catalog.options.create` | Add a configurable product option | `optionCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:78`) |
| `catalog.options.update` | Update option properties or custom fields | `optionUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:95`) |
| `catalog.options.delete` | Remove an option after clearing variant links | n/a |
| `catalog.option-values.create` | Persist an option value for a product option | `optionValueCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:107`) |
| `catalog.option-values.update` | Patch an option value | `optionValueUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:125`) |
| `catalog.option-values.delete` | Remove an option value and unlink affected variants | n/a |

`optionValueCreateSchema` mirrors option fields but scopes them to a single option (`optionId`) and maintains ordering via `position`. Deletions automatically clean up `CatalogVariantOptionValue` links so variants remain consistent (`packages/core/src/modules/catalog/commands/options.ts:430`).

## Price commands — `catalog.prices.*`

Stored in `packages/core/src/modules/catalog/commands/prices.ts`.

| Command id | Purpose | Schema |
| --- | --- | --- |
| `catalog.prices.create` | Add a price row for a variant | `priceCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:122`) |
| `catalog.prices.update` | Update price attributes | `priceUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:140`) |
| `catalog.prices.delete` | Remove a price entry | n/a |

Key fields:

- `variantId`, `organizationId`, `tenantId`.
- `currencyCode` (ISO-4217), optional `kind` (`list`, `sale`, `tier`, `custom`).
- Quantity bands: `minQuantity`, `maxQuantity`.
- Price components: `unitPriceNet`, `unitPriceGross`, `taxRate`.
- Effective dates: `startsAt`, `endsAt` (coerced to `Date` by Zod).

## Attribute schema commands — `catalog.attributeSchemas.*`

Reusable attribute schema templates live in `packages/core/src/modules/catalog/commands/attributeSchemas.ts` and back the `/api/catalog/attribute-schemas` REST endpoint.

| Command id | Purpose | Schema |
| --- | --- | --- |
| `catalog.attributeSchemas.create` | Persist a reusable schema template scoped to an organization/tenant | `attributeSchemaTemplateCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:146`) |
| `catalog.attributeSchemas.update` | Patch template metadata or definitions | `attributeSchemaTemplateUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:154`) |
| `catalog.attributeSchemas.delete` | Soft delete a template (requires products to detach first) | n/a |

Highlights:

- Templates store the same `attributeSchema` payload you would normally attach to a product, but as JSON on `catalog_attribute_schemas`.
- Products reference templates via `attributeSchemaId`. If no per-product override is present, the shared definition is used verbatim; otherwise `attributeSchema` overrides only that product.
- Deleting a template is blocked while products still point at it, so detach or migrate those products before cleanup. Undo logs capture before/after snapshots for safe rollbacks.

## Customising price selection

All API surfaces that need “best price” calculations resolve the DI token `catalogPricingService`, which wraps `resolveCatalogPrice()` from `packages/core/src/modules/catalog/lib/pricing.ts`. The helper emits `catalog.pricing.resolve.before` and `catalog.pricing.resolve.after` events and walks a prioritized hook registry, falling back to the built-in layered selection (`selectBestPrice`) when no hook handles the request.

You can plug in custom logic (e.g., loyalty tiers, partner overrides) by registering a resolver from any module initialization file:

```ts
import { registerCatalogPricingResolver } from '@open-mercato/core/modules/catalog/lib/pricing'

registerCatalogPricingResolver(
  async (rows, ctx) => {
    // rows: all matching CatalogProductPrice rows (with populated offer/variant/product)
    // ctx: PricingContext (channelId, userId, quantity, date, etc.)
    const partnerPrice = rows.find((row) => row.metadata?.partner === ctx.customerId)
    if (partnerPrice) return partnerPrice
    return undefined // fall back to the next resolver / default algorithm
  },
  { priority: 100 },
)
```

- Resolvers run in descending priority order (default is `0`); return `undefined` to defer to the next handler.
- Returning `null` stops the pipeline and instructs callers that no price applies.
- The default resolver (`selectBestPrice`) still runs last so existing behaviour remains unless you override it.
- The DI service automatically injects the app’s event bus; listeners can override prices by handling `catalog.pricing.resolve.before|after` (each payload exposes `rows`, `context`, `result`, and `setResult`, mirroring the sales calculation hooks).
- Swap the pricing implementation entirely by registering your own `catalogPricingService` via DI if you need to replace the pipeline wholesale.

## Feature flags

RBAC gates for REST/UX surfaces are declared in `packages/core/src/modules/catalog/acl.ts:1`:

- `catalog.products.view` / `catalog.products.manage`
- `catalog.variants.manage`
- `catalog.options.manage`
- `catalog.pricing.manage`
- `catalog.settings.manage`

Grant these to API keys or roles you intend to use with wrapper endpoints so future upgrades continue to respect access boundaries.

---

You can call the command bus directly or go through the REST endpoints above—the schemas listed here ensure imports, integrations, and tests remain aligned with the core module.
