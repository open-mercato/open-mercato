---
title: Catalog
description: Command payloads for managing catalog products, variants, options, and pricing.
---

import OpenApiExplorerBanner from '@site/src/components/OpenApiExplorerBanner';

<OpenApiExplorerBanner />

The catalog module exposes both command handlers and REST endpoints (see `/api/catalog/products`, `/api/catalog/attribute-schemas`, `/api/catalog/variants`, `/api/catalog/options`, `/api/catalog/prices`, and `/api/catalog/price-kinds`). The commands documented below remain the source of truth for validations and undo metadata, so you can safely script imports, seed data, or build bespoke HTTP wrappers even as new HTTP routes come online.

## Running catalog commands

```ts
import { createRequestContainer } from '@/lib/di/container'
import type { CommandBus } from '@open-mercato/shared/lib/commands'

const container = await createRequestContainer()
const commandBus = container.resolve<CommandBus>('commandBus')

await commandBus.execute('catalog.products.create', {
  input: {
    organizationId,
    tenantId,
    name: 'Starter T-Shirt',
    code: 'tee-basic',
    primaryCurrencyCode: 'USD',
    metadata: { category: 'apparel' },
    customFields: { material: 'cotton' }
  },
  ctx: { auth, container }
})
```

- Every command enforces tenant and organization scope via `ensureTenantScope`/`ensureOrganizationScope` (`packages/core/src/modules/catalog/commands/shared.ts:42`).
- Custom fields can be supplied either as `customFields` object or prefixed keys (`cf_color`); handlers call `parseWithCustomFields` and `setCustomFieldsIfAny` to persist values (`packages/core/src/modules/catalog/commands/products.ts:100`).
- Undo metadata is logged automatically; the audit log payload includes before/after snapshots for δ previews and rollbacks.

## Product commands — `catalog.products.*`

Handlers live in `packages/core/src/modules/catalog/commands/products.ts`.

| Command id | Purpose | Schema |
| --- | --- | --- |
| `catalog.products.create` | Create a product master record | `productCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:18`) |
| `catalog.products.update` | Patch an existing product (only provided keys are updated) | `productUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:32`) |
| `catalog.products.delete` | Soft delete a product once variants/prices are cleaned up | n/a (requires `before.id` in the undo snapshot) |

Key fields from `productCreateSchema`:

- `organizationId`, `tenantId` — required scope identifiers.
- `name` (string, ≤255), optional `description`.
- Optional catalog metadata: `code` (lowercase slug), `statusEntryId`, `primaryCurrencyCode`, `defaultUnit`, `attributeSchemaId` reference, `attributeSchema` JSON override, `attributeValues` map, and `offers` (array of `{ channelId, title, description }`) that bind products to sales channels. When `attributeSchemaId` is provided, the product inherits a shared schema template; providing `attributeSchema` in the same payload overwrites individual fields for that single product without mutating the shared template.
- `defaultMediaId` / `defaultMediaUrl` — optional attachment handle + its SEO-friendly relative image URL for the primary product media. Upload images via `/api/attachments`, then resolve responsive URLs with `buildAttachmentImageUrl(id, { width, height, slug })` or by calling `/api/attachments/image/{id}/{slug}` directly for server-side resizing.
- Flags: `isConfigurable`, `isActive`, plus arbitrary `metadata` JSON.

Example payload:

```json
{
  "organizationId": "3d552375-7813-4e9d-8807-0283c907a9f9",
  "tenantId": "a2c6e50e-a6ef-4c7a-afe4-7b6f1998b5c2",
  "name": "Starter T-Shirt",
  "code": "tee-basic",
  "primaryCurrencyCode": "USD",
  "attributeSchemaId": "edc95a4d-9fb9-4cbc-b8ce-1b93af2c8e83",
  "attributeSchema": {
    "definitions": [
      { "key": "material", "label": "Material", "kind": "text" }
    ]
  },
  "offers": [
    { "channelId": "bf5efc35-c493-44e4-9307-5f50331a7405", "title": "Online store" }
  ],
  "isConfigurable": true,
  "metadata": { "category": "apparel" },
  "customFields": { "material": "cotton" }
}
```

## Variant commands — `catalog.variants.*`

Defined in `packages/core/src/modules/catalog/commands/variants.ts`.

| Command id | Purpose | Schema |
| --- | --- | --- |
| `catalog.variants.create` | Create a SKU tied to a product | `variantCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:39`) |
| `catalog.variants.update` | Patch variant attributes, dimensions, or option selections | `variantUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:65`) |
| `catalog.variants.delete` | Remove a variant after ensuring there are no prices or option links | n/a (id provided through undo payload) |

Highlights from `variantCreateSchema`:

- Required: `organizationId`, `tenantId`, `productId`.
- Optional: `name`, `sku`, `barcode`, `statusEntryId`, `isDefault`, `isActive`.
- Dimensions and weight via nested objects (`dimensions.width/height/depth/unit`, `weightValue`, `weightUnit`).
- `optionConfiguration` array linking option ids to option value selections.

## Option & option value commands — `catalog.options.*`

Both option and option value handlers are colocated in `packages/core/src/modules/catalog/commands/options.ts`.

| Command id | Purpose | Schema |
| --- | --- | --- |
| `catalog.options.create` | Add a configurable product option | `optionCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:78`) |
| `catalog.options.update` | Update option properties or custom fields | `optionUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:95`) |
| `catalog.options.delete` | Remove an option after clearing variant links | n/a |
| `catalog.option-values.create` | Persist an option value for a product option | `optionValueCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:107`) |
| `catalog.option-values.update` | Patch an option value | `optionValueUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:125`) |
| `catalog.option-values.delete` | Remove an option value and unlink affected variants | n/a |

`optionValueCreateSchema` mirrors option fields but scopes them to a single option (`optionId`) and maintains ordering via `position`. Deletions automatically clean up `CatalogVariantOptionValue` links so variants remain consistent (`packages/core/src/modules/catalog/commands/options.ts:430`).

## Price commands — `catalog.prices.*`

Stored in `packages/core/src/modules/catalog/commands/prices.ts`.

| Command id | Purpose | Schema |
| --- | --- | --- |
| `catalog.prices.create` | Add a price row for a variant | `priceCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:273`) |
| `catalog.prices.update` | Update price attributes | `priceUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:298`) |
| `catalog.prices.delete` | Remove a price entry | n/a |

Key fields:

- `variantId`, `organizationId`, `tenantId`, and `priceKindId`.
- `currencyCode` (ISO-4217) with optional price kind currency override.
- Quantity bands: `minQuantity`, `maxQuantity`.
- Price components: `unitPriceNet`, `unitPriceGross`, `taxRate`.
- Effective dates: `startsAt`, `endsAt` (coerced to `Date` by Zod).

## Price kind commands — `catalog.priceKinds.*`

Stored in `packages/core/src/modules/catalog/commands/priceKinds.ts`.

| Command id | Purpose | Schema |
| --- | --- | --- |
| `catalog.priceKinds.create` | Register a reusable price kind | `priceKindCreateSchema` (`packages/core/src/modules/catalog/data/validators.ts:258`) |
| `catalog.priceKinds.update` | Adjust labels, display mode, currency, or promotion flags | `priceKindUpdateSchema` (`packages/core/src/modules/catalog/data/validators.ts:271`) |
| `catalog.priceKinds.delete` | Soft delete a price kind after ensuring no prices reference it | n/a |

## Custom field fieldsets

Catalog products and variants no longer ship their own “attribute schema” concept. Instead they rely on the shared custom-fields engine and the `CustomFieldEntityConfig` fieldset metadata that is edited from **Entities → System entities → catalog.catalog_product** (and `catalog.catalog_product_variant`). Compose as many fieldsets as you need—e.g. `fashion`, `equipment`, `services`—and assign custom fields plus per-field groups within each set. The generated UI automatically scopes the editors, CRUD forms, and filters to the currently selected fieldset.

Key details:

- Fieldset metadata lives in `custom_field_entity_configs` and is exposed through `/api/entities/definitions?entityId=…`. The request accepts `?fieldset=<code>` to filter definitions server-side; the admin UI calls this automatically when the user switches fieldsets.
- Products (`catalog_products`) and variants (`catalog_product_variants`) persist the chosen fieldset in the `custom_fieldset_code` column. Awilix commands and CRUD handlers already accept a `customFieldsetCode` property so you can capture that selection from bespoke flows.
- Listing APIs allow a `customFieldset=<code>` query parameter so filters and the query engine interpret `cf_*` filters using the right definition set. The backend uses `buildCustomFieldFiltersFromQuery(..., { fieldset })` to scope validation and coercion.
- Because we now reuse custom fields, all of the generic helpers (`collectCustomFieldValues`, `crud.create/update` payloads, entity definitions UI) apply without a bespoke schema layer. Old attribute schema endpoints/tests have been removed; the existing migrations (up to `Migration20251116183727`) take care of dropping the template tables and extra JSON columns.

## Customising price selection

All API surfaces that need “best price” calculations resolve the DI token `catalogPricingService`, which wraps `resolveCatalogPrice()` from `packages/core/src/modules/catalog/lib/pricing.ts`. The helper emits `catalog.pricing.resolve.before` and `catalog.pricing.resolve.after` events and walks a prioritized hook registry, falling back to the built-in layered selection (`selectBestPrice`) when no hook handles the request.

You can plug in custom logic (e.g., loyalty tiers, partner overrides) by registering a resolver from any module initialization file:

```ts
import { registerCatalogPricingResolver } from '@open-mercato/core/modules/catalog/lib/pricing'

registerCatalogPricingResolver(
  async (rows, ctx) => {
    // rows: all matching CatalogProductPrice rows (with populated offer/variant/product)
    // ctx: PricingContext (channelId, userId, quantity, date, etc.)
    const partnerPrice = rows.find((row) => row.metadata?.partner === ctx.customerId)
    if (partnerPrice) return partnerPrice
    return undefined // fall back to the next resolver / default algorithm
  },
  { priority: 100 },
)
```

- Resolvers run in descending priority order (default is `0`); return `undefined` to defer to the next handler.
- Returning `null` stops the pipeline and instructs callers that no price applies.
- The default resolver (`selectBestPrice`) still runs last so existing behaviour remains unless you override it.
- The DI service automatically injects the app’s event bus; listeners can override prices by handling `catalog.pricing.resolve.before|after` (each payload exposes `rows`, `context`, `result`, and `setResult`, mirroring the sales calculation hooks).
- Swap the pricing implementation entirely by registering your own `catalogPricingService` via DI if you need to replace the pipeline wholesale.

## Feature flags

RBAC gates for REST/UX surfaces are declared in `packages/core/src/modules/catalog/acl.ts:1`:

- `catalog.products.view` / `catalog.products.manage`
- `catalog.variants.manage`
- `catalog.options.manage`
- `catalog.pricing.manage`
- `catalog.settings.manage`

Grant these to API keys or roles you intend to use with wrapper endpoints so future upgrades continue to respect access boundaries.

---

You can call the command bus directly or go through the REST endpoints above—the schemas listed here ensure imports, integrations, and tests remain aligned with the core module.
