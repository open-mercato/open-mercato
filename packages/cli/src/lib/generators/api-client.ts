import { mkdir, readFile, writeFile } from 'node:fs/promises'
import path from 'node:path'
import {
  astToString,
  COMMENT_HEADER,
  resolveRef,
  scanDiscriminators,
  transformSchema,
  type GlobalContext,
  type OpenAPI3,
  type ServerObject,
  type OpenAPITSOptions,
} from 'openapi-typescript'
import { buildOpenApiDocument, sanitizeOpenApiDocument } from '@open-mercato/shared/lib/openapi'
import type { PackageResolver } from '../resolver'
import type { GeneratorResult } from '../utils'
import { createGeneratorResult } from '../utils'

export interface ApiClientOptions {
  resolver: PackageResolver
  quiet?: boolean
}

async function ensureDir(dir: string) {
  await mkdir(dir, { recursive: true })
}

async function writeIfChanged(filePath: string, content: string): Promise<boolean> {
  try {
    const existing = await readFile(filePath, 'utf8')
    if (existing === content) return false
  } catch {
    // Ignore missing file
  }
  await writeFile(filePath, content, 'utf8')
  return true
}

function resolveBaseUrl(): string {
  return (
    process.env.OPEN_MERCATO_API_BASE_URL ||
    process.env.NEXT_PUBLIC_API_BASE_URL ||
    process.env.APP_URL ||
    'http://localhost:3000/api'
  )
}

function coerceToOpenAPI3(document: ReturnType<typeof sanitizeOpenApiDocument>): OpenAPI3 {
  const servers = (document.servers ?? []).map((server: ServerObject) => ({
    url: server.url,
    description: server.description,
    variables: server.variables ?? {},
  }))
  return { ...(document as Record<string, unknown>), servers } as OpenAPI3
}

export async function generateApiClient(options: ApiClientOptions): Promise<GeneratorResult> {
  const { resolver, quiet = false } = options
  const result = createGeneratorResult()

  const rootDir = resolver.getRootDir()
  const clientRoot = path.join(rootDir, 'packages/client')
  const generatedDir = path.join(clientRoot, 'src/generated')
  const typesOutputPath = path.join(generatedDir, 'openapi.types.ts')

  await ensureDir(generatedDir)

  // Dynamically import the modules from the generated file
  // Use cache-busting query param to ensure we get fresh imports after registry generation
  const modulesGeneratedPath = path.join(resolver.getOutputDir(), 'modules.generated')
  let modules: any[]
  try {
    const cacheBuster = `?t=${Date.now()}`
    const mod = await import(`${modulesGeneratedPath}${cacheBuster}`)
    modules = mod.modules || mod.default || []
  } catch (e) {
    result.errors.push(`Failed to import modules from ${modulesGeneratedPath}: ${(e as Error).message}`)
    console.error(`[api-client] Failed to import modules. Run 'mercato generate registry' first.`)
    return result
  }

  const rawDoc = buildOpenApiDocument(modules, {
    title: 'Open Mercato API',
    version: '1.0.0',
    description: 'Auto-generated OpenAPI document for all enabled modules.',
    servers: [{ url: resolveBaseUrl(), description: 'Default environment' }],
    baseUrlForExamples: resolveBaseUrl(),
    defaultSecurity: ['bearerAuth'],
  })
  const doc = coerceToOpenAPI3(sanitizeOpenApiDocument(rawDoc))

  const header = '// AUTO-GENERATED by mercato generate api-client -- DO NOT EDIT\n'
  const tsOptions: OpenAPITSOptions = {
    alphabetize: true,
    defaultNonNullable: false,
    arrayLength: false,
  }
  const ctx: GlobalContext = {
    additionalProperties: tsOptions.additionalProperties ?? false,
    alphabetize: tsOptions.alphabetize ?? false,
    arrayLength: tsOptions.arrayLength ?? false,
    defaultNonNullable: tsOptions.defaultNonNullable ?? true,
    discriminators: scanDiscriminators(doc, tsOptions),
    emptyObjectsUnknown: tsOptions.emptyObjectsUnknown ?? false,
    enum: tsOptions.enum ?? false,
    enumValues: tsOptions.enumValues ?? false,
    dedupeEnums: tsOptions.dedupeEnums ?? false,
    excludeDeprecated: tsOptions.excludeDeprecated ?? false,
    exportType: tsOptions.exportType ?? false,
    immutable: tsOptions.immutable ?? false,
    rootTypes: tsOptions.rootTypes ?? false,
    rootTypesNoSchemaPrefix: tsOptions.rootTypesNoSchemaPrefix ?? false,
    injectFooter: [],
    pathParamsAsTypes: tsOptions.pathParamsAsTypes ?? false,
    postTransform: typeof tsOptions.postTransform === 'function' ? tsOptions.postTransform : undefined,
    propertiesRequiredByDefault: tsOptions.propertiesRequiredByDefault ?? false,
    redoc: undefined as any,
    silent: tsOptions.silent ?? false,
    inject: tsOptions.inject,
    transform: typeof tsOptions.transform === 'function' ? tsOptions.transform : undefined,
    transformProperty: typeof tsOptions.transformProperty === 'function' ? tsOptions.transformProperty : undefined,
    makePathsEnum: tsOptions.makePathsEnum ?? false,
    generatePathParams: tsOptions.generatePathParams ?? false,
    resolve($ref: string) {
      return resolveRef(doc, $ref, { silent: tsOptions.silent ?? false })
    },
  }
  const ast = transformSchema(doc, ctx)
  const printed = astToString(ast)
  const typeSerialized = `${header}${COMMENT_HEADER}${printed.trimEnd()}\n`
  const wroteTypes = await writeIfChanged(typesOutputPath, typeSerialized)

  if (wroteTypes) {
    result.filesWritten.push(typesOutputPath)
    if (!quiet) {
      console.log('Generated Open API artifacts')
    }
  } else {
    result.filesUnchanged.push(typesOutputPath)
  }

  return result
}
