import fs from 'node:fs'
import path from 'node:path'
import crypto from 'node:crypto'
import { glob } from 'glob'
import { parseCliFileAst, extractModuleId, type ParsedCommand, type ParsedParameter } from './cli-ast-parser'

/**
 * CLI tool definition for the generated file.
 */
export interface GeneratedCliTool {
  /** Tool name in MCP format: cli_{module}_{command} */
  name: string
  /** Module ID (e.g., 'auth', 'search') */
  moduleId: string
  /** Original command name (e.g., 'add-user') */
  commandName: string
  /** Description from usage string or generated default */
  description: string
  /** Parsed parameters */
  parameters: ParsedParameter[]
  /** Original file path */
  sourcePath: string
}

/**
 * Result of the generation process.
 */
export interface GeneratorResult {
  toolCount: number
  moduleCount: number
  outputPath: string
  changed: boolean
}

function calculateChecksum(content: string): string {
  return crypto.createHash('md5').update(content).digest('hex')
}

function ensureDir(filePath: string): void {
  fs.mkdirSync(path.dirname(filePath), { recursive: true })
}

/**
 * Generate CLI tools file by scanning all CLI files in the monorepo.
 */
export async function generateCliTools(options?: {
  rootDir?: string
  outputDir?: string
  quiet?: boolean
}): Promise<GeneratorResult> {
  const rootDir = options?.rootDir ?? process.cwd()
  const outputDir = options?.outputDir ?? path.join(rootDir, 'packages/ai-assistant/generated')
  const quiet = options?.quiet ?? false

  const outputFile = path.join(outputDir, 'cli-tools.generated.ts')
  const checksumFile = path.join(outputDir, 'cli-tools.generated.checksum')

  // Scan for CLI files
  const patterns = [
    'packages/*/src/modules/*/cli.ts',
  ]

  const cliFiles: string[] = []
  for (const pattern of patterns) {
    const matches = await glob(pattern, { cwd: rootDir, absolute: true })
    cliFiles.push(...matches)
  }

  if (!quiet) {
    console.log(`[CLI Tools Generator] Scanning ${cliFiles.length} CLI files...`)
  }

  const allTools: GeneratedCliTool[] = []
  const modules = new Set<string>()

  for (const cliFile of cliFiles) {
    try {
      const moduleId = extractModuleId(cliFile)
      const commands = parseCliFileAst(cliFile)

      for (const cmd of commands) {
        const toolName = `cli_${moduleId}_${cmd.name.replace(/-/g, '_')}`
        const description = cmd.usageString
          ? cmd.usageString.replace(/^Usage:\s*/, '')
          : `CLI: mercato ${moduleId} ${cmd.name}`

        allTools.push({
          name: toolName,
          moduleId,
          commandName: cmd.name,
          description,
          parameters: cmd.parameters,
          sourcePath: path.relative(rootDir, cliFile),
        })

        modules.add(moduleId)
      }
    } catch (error) {
      if (!quiet) {
        console.error(`[CLI Tools Generator] Error processing ${cliFile}:`, error)
      }
    }
  }

  // Sort tools by name for consistent output
  allTools.sort((a, b) => a.name.localeCompare(b.name))

  // Compute checksum based on tools data (excluding timestamp)
  const toolsJson = JSON.stringify(allTools, null, 2)
  const newChecksum = calculateChecksum(toolsJson)

  // Check if content changed
  let changed = true
  if (fs.existsSync(checksumFile)) {
    try {
      const existingChecksum = fs.readFileSync(checksumFile, 'utf8').trim()
      if (existingChecksum === newChecksum) {
        changed = false
      }
    } catch {
      // Ignore checksum read errors
    }
  }

  if (changed) {
    // Generate the output file with current timestamp
    const generatedContent = generateOutputContent(allTools, toolsJson)
    ensureDir(outputFile)
    fs.writeFileSync(outputFile, generatedContent)
    fs.writeFileSync(checksumFile, newChecksum)

    if (!quiet) {
      console.log(`[CLI Tools Generator] Generated ${outputFile}`)
      console.log(`[CLI Tools Generator] Total: ${allTools.length} tools from ${modules.size} modules`)
    }
  } else {
    if (!quiet) {
      console.log(`[CLI Tools Generator] No changes detected, skipping write`)
    }
  }

  return {
    toolCount: allTools.length,
    moduleCount: modules.size,
    outputPath: outputFile,
    changed,
  }
}

/**
 * Generate the TypeScript output content.
 */
function generateOutputContent(tools: GeneratedCliTool[], toolsJson: string): string {
  return `// AUTO-GENERATED by cli-tools-generator
// Do not edit manually. Run 'yarn --cwd packages/ai-assistant generate:cli-tools' to regenerate.
// Generated at: ${new Date().toISOString()}

/**
 * Parsed parameter from CLI command.
 */
export interface ParsedParameter {
  name: string
  aliases: string[]
  required: boolean
  type: 'string' | 'boolean'
}

/**
 * Generated CLI tool definition.
 */
export interface GeneratedCliTool {
  /** Tool name in MCP format: cli_{module}_{command} */
  name: string
  /** Module ID (e.g., 'auth', 'search') */
  moduleId: string
  /** Original command name (e.g., 'add-user') */
  commandName: string
  /** Description from usage string or generated default */
  description: string
  /** Parsed parameters */
  parameters: ParsedParameter[]
  /** Original file path */
  sourcePath: string
}

/**
 * All CLI tools extracted from the codebase.
 */
export const cliTools: GeneratedCliTool[] = ${toolsJson}

/**
 * Get CLI tools by module ID.
 */
export function getCliToolsByModule(moduleId: string): GeneratedCliTool[] {
  return cliTools.filter(tool => tool.moduleId === moduleId)
}

/**
 * Get all unique module IDs.
 */
export function getCliModuleIds(): string[] {
  return [...new Set(cliTools.map(tool => tool.moduleId))].sort()
}

/**
 * Get a CLI tool by name.
 */
export function getCliToolByName(name: string): GeneratedCliTool | undefined {
  return cliTools.find(tool => tool.name === name)
}
`
}

// Main entry point when run as a script
if (import.meta.url === `file://${process.argv[1]}`) {
  generateCliTools({ quiet: false })
    .then(result => {
      console.log(`\nGeneration complete:`)
      console.log(`  Tools: ${result.toolCount}`)
      console.log(`  Modules: ${result.moduleCount}`)
      console.log(`  Output: ${result.outputPath}`)
      console.log(`  Changed: ${result.changed}`)
      process.exit(0)
    })
    .catch(err => {
      console.error('Generation failed:', err)
      process.exit(1)
    })
}
