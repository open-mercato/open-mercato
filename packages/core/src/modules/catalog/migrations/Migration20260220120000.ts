import { Migration } from '@mikro-orm/migrations'

export class Migration20260220120000 extends Migration {

  override async up(): Promise<void> {
    this.addSql(`
      create table "catalog_price_history_entries" (
        "id" uuid not null default gen_random_uuid(),
        "tenant_id" uuid not null,
        "organization_id" uuid not null,
        "price_id" uuid not null,
        "product_id" uuid not null,
        "variant_id" uuid null,
        "offer_id" uuid null,
        "channel_id" uuid null,
        "price_kind_id" uuid not null,
        "price_kind_code" text not null,
        "currency_code" text not null,
        "unit_price_net" numeric(14, 4) null,
        "unit_price_gross" numeric(14, 4) null,
        "tax_rate" numeric(6, 4) null,
        "tax_amount" numeric(14, 4) null,
        "min_quantity" int null,
        "max_quantity" int null,
        "starts_at" timestamptz null,
        "ends_at" timestamptz null,
        "recorded_at" timestamptz not null,
        "change_type" text not null,
        "source" text not null,
        "is_announced" boolean null,
        "idempotency_key" text null,
        "metadata" jsonb null,
        constraint "catalog_price_history_entries_pkey" primary key ("id")
      );
    `)

    // Composite indexes with recorded_at DESC for efficient lookback queries
    this.addSql(`
      create index "catalog_price_history_product_channel_agnostic_idx"
        on "catalog_price_history_entries" ("tenant_id", "organization_id", "product_id", "price_kind_id", "currency_code", "recorded_at" desc);
    `)
    this.addSql(`
      create index "catalog_price_history_product_channel_scoped_idx"
        on "catalog_price_history_entries" ("tenant_id", "organization_id", "product_id", "channel_id", "price_kind_id", "currency_code", "recorded_at" desc);
    `)
    this.addSql(`
      create index "catalog_price_history_variant_channel_agnostic_idx"
        on "catalog_price_history_entries" ("tenant_id", "organization_id", "variant_id", "price_kind_id", "currency_code", "recorded_at" desc);
    `)
    this.addSql(`
      create index "catalog_price_history_variant_channel_scoped_idx"
        on "catalog_price_history_entries" ("tenant_id", "organization_id", "variant_id", "channel_id", "price_kind_id", "currency_code", "recorded_at" desc);
    `)
    this.addSql(`
      create index "catalog_price_history_offer_idx"
        on "catalog_price_history_entries" ("tenant_id", "organization_id", "offer_id", "price_kind_id", "currency_code", "recorded_at" desc);
    `)
    this.addSql(`
      create index "catalog_price_history_price_id_idx"
        on "catalog_price_history_entries" ("tenant_id", "organization_id", "price_id");
    `)

    // Partial unique index for idempotency key deduplication on command retry
    this.addSql(`
      create unique index "catalog_price_history_idempotency_key_idx"
        on "catalog_price_history_entries" ("tenant_id", "organization_id", "idempotency_key")
        where "idempotency_key" is not null;
    `)

    // MANUAL DDL: immutability trigger (not generated by MikroORM)
    this.addSql(`
      create function prevent_history_modification()
      returns trigger as $$
      begin
        raise exception 'catalog_price_history_entries is immutable';
      end;
      $$ language plpgsql;
    `)
    this.addSql(`
      create trigger history_immutable
        before update or delete
        on "catalog_price_history_entries"
        for each row execute function prevent_history_modification();
    `)
    // Runtime DB role: restrict to SELECT + INSERT only (deployment runbook step):
    // REVOKE UPDATE, DELETE ON catalog_price_history_entries FROM app_role;
    // Apply to the correct app role name for the environment.
  }

  override async down(): Promise<void> {
    this.addSql('drop trigger if exists history_immutable on "catalog_price_history_entries";')
    this.addSql('drop function if exists prevent_history_modification();')
    this.addSql('drop table if exists "catalog_price_history_entries" cascade;')
  }

}
