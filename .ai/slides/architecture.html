<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Open Mercato Architecture</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #0f1a1f;
        --bg-soft: #14242b;
        --surface: rgba(20, 36, 43, 0.72);
        --surface-strong: rgba(23, 44, 54, 0.95);
        --text: #eef6f8;
        --muted: #9bb2bd;
        --accent: #48c6d9;
        --accent-2: #f1c76f;
        --accent-3: #8ee2b1;
        --shadow: 0 30px 60px rgba(2, 8, 12, 0.45);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Space Grotesk", system-ui, sans-serif;
        color: var(--text);
        background: radial-gradient(1400px 800px at 15% 10%, #1c3b45 0%, rgba(15, 26, 31, 0.2) 50%),
          radial-gradient(1200px 700px at 90% 90%, rgba(68, 175, 151, 0.16) 0%, rgba(15, 26, 31, 0) 55%),
          linear-gradient(160deg, #0c1418 0%, #0f1a1f 45%, #111e24 100%);
        min-height: 100vh;
        overflow: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: radial-gradient(rgba(255, 255, 255, 0.04) 1px, transparent 1px);
        background-size: 24px 24px;
        opacity: 0.45;
        pointer-events: none;
      }

      .deck {
        position: relative;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        padding: 28px 40px 24px;
        gap: 20px;
        z-index: 1;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .brand img {
        width: 46px;
        height: 46px;
        filter: drop-shadow(0 0 18px rgba(72, 198, 217, 0.4));
      }

      .brand h1 {
        font-size: 1.6rem;
        margin: 0;
        letter-spacing: 0.03em;
      }

      .meta {
        display: flex;
        gap: 12px;
        align-items: center;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .meta span,
      .meta button {
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(9, 18, 23, 0.6);
      }

      .meta button {
        color: var(--text);
        font-family: inherit;
        cursor: pointer;
        transition: border 0.2s ease, transform 0.2s ease;
      }

      .meta button:hover {
        border-color: rgba(72, 198, 217, 0.6);
        transform: translateY(-1px);
      }

      .share-button {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .share-button svg {
        width: 16px;
        height: 16px;
        fill: none;
        stroke: currentColor;
        stroke-width: 1.6;
      }

      main {
        flex: 1;
        display: grid;
        grid-template-columns: 240px minmax(0, 1fr);
        gap: 20px;
        align-items: stretch;
      }

      .slide {
        position: relative;
        padding: 42px 52px;
        background: var(--surface);
        border-radius: 28px;
        box-shadow: var(--shadow);
        border: 1px solid rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(6px);
        overflow-y: auto;
        max-height: calc(100vh - 220px);
        animation: slideIn 0.5s ease both;
      }

      .slide-list {
        padding: 18px;
        border-radius: 24px;
        background: rgba(8, 16, 20, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: var(--shadow);
        overflow-y: auto;
        max-height: calc(100vh - 220px);
      }

      .slide-list h2 {
        margin: 0 0 12px;
        font-size: 1rem;
        color: var(--accent-2);
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      .slide-list ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .slide-list button {
        width: 100%;
        text-align: left;
        background: rgba(9, 18, 23, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        font-family: inherit;
        cursor: pointer;
        transition: border 0.2s ease, transform 0.2s ease;
      }

      .slide-list button:hover {
        border-color: rgba(72, 198, 217, 0.6);
        transform: translateY(-1px);
      }

      .slide-list button.active {
        border-color: rgba(241, 199, 111, 0.7);
        box-shadow: 0 0 0 1px rgba(241, 199, 111, 0.4);
      }

      .nav-stack {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .slide h1,
      .slide h2,
      .slide h3 {
        margin-top: 0;
        letter-spacing: 0.02em;
      }

      .slide h1 {
        font-size: clamp(2.2rem, 4vw, 3.4rem);
      }

      .slide h2 {
        font-size: clamp(1.6rem, 3vw, 2.4rem);
      }

      .slide p {
        font-size: 1.05rem;
        line-height: 1.6;
        color: var(--text);
      }

      .slide strong {
        color: var(--accent-2);
      }

      .slide ul {
        list-style: none;
        padding: 0;
        margin: 18px 0 24px;
        display: grid;
        gap: 12px;
      }

      .slide ul li {
        position: relative;
        padding-left: 28px;
        color: var(--muted);
      }

      .slide ul li::before {
        content: "";
        position: absolute;
        left: 0;
        top: 8px;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: linear-gradient(120deg, var(--accent), var(--accent-3));
        box-shadow: 0 0 10px rgba(72, 198, 217, 0.6);
      }

      .jump-links {
        margin-top: 24px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .jump-links a {
        color: var(--text);
        text-decoration: none;
        border: 1px solid rgba(255, 255, 255, 0.12);
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(9, 18, 23, 0.6);
        transition: border 0.2s ease, transform 0.2s ease;
      }

      .jump-links a:hover {
        border-color: rgba(72, 198, 217, 0.6);
        transform: translateY(-1px);
      }

      .slide code {
        font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        background: rgba(255, 255, 255, 0.08);
        padding: 2px 6px;
        border-radius: 6px;
        font-size: 0.92rem;
      }

      pre {
        background: var(--surface-strong);
        padding: 16px 20px;
        border-radius: 18px;
        overflow: auto;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      pre code {
        background: none;
        padding: 0;
        color: var(--accent-3);
        font-size: 0.9rem;
        display: block;
      }

      .nav {
        display: grid;
        place-items: center;
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(8, 16, 20, 0.7);
        color: var(--text);
        cursor: pointer;
        transition: transform 0.2s ease, border 0.2s ease;
        font-size: 1.6rem;
      }

      .nav:hover {
        transform: translateY(-2px) scale(1.02);
        border-color: rgba(72, 198, 217, 0.6);
      }

      .nav:active {
        transform: translateY(1px) scale(0.98);
      }

      .notes {
        background: rgba(7, 14, 18, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 18px;
        padding: 16px 20px;
        color: var(--muted);
        font-size: 0.95rem;
        display: none;
      }

      .notes.visible {
        display: block;
      }

      footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .progress {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .progress-bar {
        width: 160px;
        height: 6px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.1);
        overflow: hidden;
      }

      .progress-bar span {
        display: block;
        height: 100%;
        background: linear-gradient(120deg, var(--accent), var(--accent-2));
        width: 0;
        transition: width 0.3s ease;
      }

      .hint {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .error {
        background: rgba(118, 33, 33, 0.4);
        border: 1px solid rgba(235, 125, 125, 0.4);
        padding: 12px 16px;
        border-radius: 12px;
        margin-top: 16px;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 900px) {
        .deck {
          padding: 18px;
        }

        main {
          grid-template-columns: 1fr;
        }

        .nav,
        .slide-list {
          display: none;
        }

        .slide {
          padding: 28px;
          max-height: none;
        }

        header {
          flex-direction: column;
          align-items: flex-start;
        }
      }
    </style>
  </head>
  <body>
    <div class="deck">
      <header>
        <div class="brand">
          <img src="../../public/open-mercato.svg" alt="Open Mercato logo" />
          <h1>Open Mercato Architecture</h1>
        </div>
        <div class="meta">
          <span id="slide-title">Loading slides...</span>
          <button id="open-notes" type="button">Presenter Notes</button>
          <button id="share-slide" class="share-button" type="button" aria-label="Copy slide link">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M7 12a3 3 0 0 1 3-3h4"></path>
              <path d="M10 9l-2 2 2 2"></path>
              <path d="M17 12a3 3 0 0 1-3 3h-4"></path>
              <path d="M14 15l2-2-2-2"></path>
            </svg>
            Copy link
          </button>
        </div>
      </header>

      <main>
        <aside class="slide-list" id="slide-list"></aside>
        <section class="slide" id="slide"></section>
      </main>

      <section class="notes" id="notes"></section>

      <footer>
        <div class="progress">
          <div class="progress-bar"><span id="progress"></span></div>
          <span id="count">0 / 0</span>
        </div>
        <div class="nav-stack">
          <button class="nav" id="prev" aria-label="Previous slide">&#8592;</button>
          <button class="nav" id="next" aria-label="Next slide">&#8594;</button>
        </div>
        <div class="hint">Use arrow keys to navigate, N to toggle notes</div>
      </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
      const rawSlides = [
  "# Open Mercato Architecture\n\n**Modular, multi-tenant platform where modules are the unit of UI + API + data + DI + events \u2014 wired together by generated registries.**\n\n## Build-time -> Runtime\n\nModules (packages + app overrides) provide:\n- Pages (`frontend/*`, `backend/*`)\n- APIs (`api/<method>/*`)\n- DB entities, DI registrars, subscribers, widgets, i18n\n\nGenerators (`yarn modules:prepare`) scan enabled modules and emit:\n- `modules.generated.ts`, `entities.generated.ts`, `di.generated.ts`\n- Widget registries and module metadata\n\nRuntime (Next.js App Router) loads registries to:\n- Route pages and API requests\n- Bootstrap ORM entities + DI\n- Enforce auth/RBAC via metadata\n- Run services (query engine, data engine) and trigger events/subscribers\n\n## Core runtime components\n\n- Next.js App Router: frontend + backend apps, plus a catch-all API router\n- Awilix DI (request-scoped): container per request; modules extend/override via `di.ts`\n- PostgreSQL + MikroORM: per-module entities/migrations (no global schema)\n- Query Engine + Data Engine: fast reads + coordinated writes and side effects\n- Events + Subscribers/Workers: writes emit domain events, subscribers react\n- Custom Entities & Fields (EAV): runtime-defined schemas/fields stored as JSONB\n\n## Extensibility\n\n- Overlay overrides: `src/modules/<module>/...` overrides package modules without forking\n- Enable/disable modules via `src/modules.ts` (module manifest)\n- Injection widgets: cross-module UI extension without tight coupling\n- Strict tenant/org scoping: propagated through services, routes, and query helpers\n\n<div class=\"jump-links\">\n  <span>Jump to:</span>\n  <a href=\"#slide-open-mercato-architecture\">Architecture Diagram</a>\n  <a href=\"#slide-module-anatomy-and-auto-discovery\">Module Anatomy</a>\n  <a href=\"#slide-request-flow-and-commands\">Request Flow</a>\n  <a href=\"#slide-data-model-and-extensibility\">Data Model</a>\n  <a href=\"#slide-search-indexing-and-events\">Search + Events</a>\n  <a href=\"#slide-runtime-boot-and-guardrails\">Runtime Boot</a>\n</div>\n\n:::notes\nOpen Mercato is built around modules \u2014 each module can ship backend pages, frontend pages, APIs, validation, database entities, DI wiring, and event subscribers. At build time, we run generators that scan enabled modules (including app-level overrides) and produce registries like modules.generated.ts, entities.generated.ts, and di.generated.ts. At runtime, Next.js uses those registries to route pages and API calls, while a request-scoped Awilix container assembles services and lets modules override behavior cleanly. Data lives in Postgres via MikroORM with per-module schemas/migrations, plus a custom entities/fields layer for runtime-defined models. Finally, writes emit events and subscribers handle side effects like indexing or workflows. The result is a platform that\u2019s both extensible and production-guardrailed.\n:::\n",
  "# Deployment & Building Blocks\n\n## Core runtime (always there)\n\n- Next.js app (monolith runtime)\n- Serves UI (backend + frontend) and API (`/api/*`) in one deployable unit\n- PostgreSQL (system tables + custom entities/fields)\n- Common default: pgvector-enabled Postgres (see `pgvector/pgvector` in `docker-compose.yml`)\n\n## Optional infra services (plug-in, scale-out)\n\n- Cache layer (`CACHE_STRATEGY`)\n  - `memory` (default/dev)\n  - `redis` (multi-node / distributed cache) via ioredis\n  - `sqlite` (local persistent cache) via better-sqlite3\n  - `jsonfile` (local/debug)\n- Queue layer (`QUEUE_STRATEGY`)\n  - `local` (file-based in `.queue`)\n  - `async` (BullMQ on Redis)\n- Search layer (multi-strategy)\n  - `tokens` (Postgres-backed, works with encrypted data)\n  - `fulltext` (Meilisearch)\n  - `vector` (embeddings)\n  - Default preference: `fulltext` \u2192 `vector` \u2192 `tokens`\n- Vector database drivers\n  - `pgvector`, `ChromaDB`, `Qdrant`\n  - Embeddings providers are configurable\n\n## Can be deployed on different machines\n\n- Web/API nodes: Next.js app behind a load balancer\n- Worker nodes: queue workers (search indexers, async jobs)\n- Shared services: Postgres, Redis, Meilisearch, optional vector DB\n\n```mermaid\nflowchart LR\n  subgraph Clients\n    B[Browser Admin UI]\n    F[Frontend app / mobile]\n    I[Integrations]\n  end\n\n  subgraph AppNode[App nodes (scale horizontally)]\n    NX[Next.js runtime<br/>UI and API]\n  end\n\n  subgraph Workers[Worker nodes (optional)]\n    W1[Queue workers<br/>search indexing, async jobs]\n  end\n\n  PG[(PostgreSQL<br/>pgvector optional)]\n  R[(Redis)]\n  MS[(Meilisearch)]\n  VDB[(Vector DB<br/>pgvector ChromaDB Qdrant)]\n\n  B --> NX\n  F --> NX\n  I --> NX\n\n  NX --> PG\n\n  NX -->|CACHE_STRATEGY redis| R\n  NX -->|CACHE_STRATEGY memory sqlite jsonfile| NX\n\n  NX -->|QUEUE_STRATEGY async BullMQ| R\n  NX -->|QUEUE_STRATEGY local queue| NX\n\n  W1 -->|BullMQ jobs| R\n  W1 --> PG\n\n  NX -->|fulltext search| MS\n  NX -->|vector search| VDB\n  NX -->|tokens fallback| PG\n```\n\n:::notes\nThis diagram shows Open Mercato as a clean set of building blocks. At the center is the Next.js runtime, which can run as a single app or scale horizontally. Postgres is the main system of record, and we commonly run it with pgvector enabled. From there you can add optional infrastructure: Redis for a distributed cache and for BullMQ queues, Meilisearch for fast typo-tolerant full-text search, and a vector store for semantic search\u2014either pgvector, ChromaDB, or Qdrant. The queue and indexing workers can move to separate machines in production: app nodes handle requests, worker nodes process async jobs, and all nodes share Postgres plus any external search services.\n:::\n",
  "# Search, Indexing, and Events\n\nSearch is modular and supports fulltext, vector, and token strategies.\n\n- Search configs live at `src/modules/<module>/search.ts`\n- Indexing runs sync or via queues and workers\n- Presenters are defined per entity for human-readable results\n\n```mermaid\nflowchart LR\n  CRUD[CRUD Command] --> IDX[Indexer]\n  IDX --> FT[Fulltext]\n  IDX --> VEC[Vector]\n  IDX --> TOK[Tokens]\n  FT --> UI[Cmd+K / Search UI]\n  VEC --> UI\n  TOK --> UI\n```\n\n:::notes\nCover the idea that search is a first-class module with multiple strategies. Indexing is an evented side effect, not an afterthought.\n:::\n",
  "# Runtime Boot and Guardrails\n\nThe runtime bootstraps modules, entities, and DI registrars from generated files.\n\n- Registries: modules, entities, DI, widgets, and CLIs\n- Multi-tenant scope is enforced in APIs and queries\n- Encryption helpers protect sensitive fields at rest\n- Workers and subscribers handle async work safely\n\n```mermaid\nflowchart TB\n  GEN[modules:prepare] --> REG[Generated Registries]\n  REG --> DI[DI Container]\n  DI --> API[Runtime APIs]\n  DI --> UI[Admin UI]\n```\n\n:::notes\nHighlight how bootstrapping keeps the system consistent and secure. Mention guardrails: tenant scope, encryption helpers, and queue workers.\n:::\n",
  "# Headless Deployment\n\n## What \u201cheadless\u201d means in Open Mercato\n\n- Run Open Mercato as a pure backend platform\n- Web/mobile/partner portals use the same APIs as the admin\n- Modules expose REST handlers under `src/modules/<module>/api/...`\n- A catch-all API router wires everything together\n- Swap UI layers without forking backend logic (RBAC, scoping, events, indexing)\n\n## Why it\u2019s easy (platform guarantees)\n\n- Consistent REST APIs via CRUD factory (`makeCrudRoute`)\n- Standardized GET/POST/PUT/DELETE behaviors\n- Built-in tenant + organization scoping\n- Built-in RBAC metadata (`requireAuth`, `requireFeatures`)\n- Hooks into commands, events, indexing, and custom fields\n- Same runtime for admin UI and headless clients\n\n## OpenAPI & docs (contract + automation)\n\n- Every API route exports `openApi` (required)\n- Zod schemas keep validation and docs aligned\n- CRUD endpoints use `createCrudOpenApiFactory(...)`\n- Live documentation endpoints:\n  - `GET /api/docs/openapi` \u2192 OpenAPI 3.1 JSON\n  - `GET /api/docs/markdown` \u2192 Markdown spec\n  - `GET /docs/api` \u2192 interactive explorer\n\n## Typical headless consumers (examples)\n\n- Web storefront / mobile app / partner portal\n- Integration layer (ERP sync, warehouse, billing)\n- External automations (Zapier/n8n-style scripts) with OpenAPI + bearer tokens\n\n```mermaid\nflowchart LR\n  C1[Web app<br/>React/Next/Vue] --> API[/Open Mercato REST API<br/>/api/*/]\n  C2[Mobile app<br/>iOS/Android] --> API\n  C3[Partner/Integrations<br/>ETL, ERP, BI] --> API\n\n  API --> MOD[Module routes<br/>src/modules/*/api/*]\n  MOD --> SVC[DI services<br/>Query + Data engine<br/>Commands + Events]\n  SVC --> DB[(PostgreSQL)]\n  SVC --> DOCS[OpenAPI generator<br/>from per-route openApi]\n\n  DOCS --> O1[GET /api/docs/openapi<br/>OpenAPI 3.1 JSON]\n  DOCS --> O2[GET /api/docs/markdown<br/>Markdown spec]\n  DOCS --> O3[GET /docs/api<br/>Explorer UI]\n```\n\n:::notes\nHeadless is straightforward in Open Mercato because the platform is API-first. Modules expose their APIs under src/modules/<module>/api, and both the admin UI and any external client use the same /api/* endpoints. Those routes are usually built with the CRUD factory, so you automatically get consistent method handling, tenant/org scoping, RBAC guards, and integration with commands and events. On top of that, every route exports an openApi definition, so we can generate a live OpenAPI 3.1 document and also export it as Markdown. That makes client generation, contract testing, and external integrations much easier.\n:::\n",
  "# Default Modules Map\n\n## Foundation / Platform\n\n- auth (logins, sessions, roles, user ACL overrides)\n- directory (tenants + organizations, multi-tenant scope)\n- configs (system configuration)\n- entities (custom entities + custom fields (EAV) + encryption maps)\n- query_index (query/index layer for fast filtering/search support)\n- audit_logs (audit trail)\n- attachments (files/attachments)\n- api_keys (integration keys)\n- api_docs (OpenAPI explorer + OpenAPI JSON/Markdown endpoints)\n- dictionaries (shared dictionaries/value sets)\n- currencies (currency primitives)\n\n## Business domains\n\n- customers (CRM: companies/people/deals/activities/todos/tags)\n- catalog (products/catalog)\n- sales (orders/quotes and related sales docs)\n- booking (resources/team/availability/scheduling)\n\n## UX / orchestration\n\n- dashboards (dashboard widgets + layout)\n- perspectives (saved table/list views)\n- workflows (workflow orchestration)\n- business_rules (rules engine + logs)\n- feature_toggles (feature flags)\n\n## Search / AI\n\n- search (multi-strategy search + indexing pipeline)\n- vector (vector infra used by semantic search)\n\n## Extra modules enabled by default\n\n- content (content module)\n- onboarding (self-serve onboarding)\n- events (events primitives)\n- example (reference/demo module)\n\n**Key message:** Everything above is modular: disable in `src/modules.ts`, override via `src/modules/<module>/...`, or add your own package module.\n\n```mermaid\nflowchart TB\n  subgraph Foundation[\"Foundation / Platform\"]\n    auth[auth]\n    directory[directory]\n    configs[configs]\n    entities[entities]\n    query_index[query_index]\n    audit_logs[audit_logs]\n    attachments[attachments]\n    api_keys[api_keys]\n    api_docs[api_docs]\n    dictionaries[dictionaries]\n    currencies[currencies]\n  end\n\n  subgraph Business[\"Business domains\"]\n    customers[customers]\n    catalog[catalog]\n    sales[sales]\n    booking[booking]\n  end\n\n  subgraph UX[\"UX / orchestration\"]\n    dashboards[dashboards]\n    perspectives[perspectives]\n    workflows[workflows]\n    business_rules[business_rules]\n    feature_toggles[feature_toggles]\n  end\n\n  subgraph SearchAI[\"Search / AI\"]\n    search[search]\n    vector[vector]\n  end\n\n  subgraph Extra[\"Extra (default-enabled)\"]\n    content[content]\n    onboarding[onboarding]\n    events[events]\n    example[example]\n  end\n\n  %% Conceptual links (composition/usage, not DB relations)\n  directory --> auth\n  directory --> customers\n  directory --> sales\n  directory --> booking\n\n  entities --> customers\n  entities --> catalog\n  entities --> sales\n  entities --> booking\n\n  query_index --> customers\n  query_index --> catalog\n  query_index --> sales\n  query_index --> booking\n\n  search --> customers\n  search --> catalog\n  search --> sales\n  search --> booking\n  search --> vector\n\n  dashboards --> customers\n  dashboards --> sales\n  dashboards --> booking\n  perspectives --> customers\n  api_docs --> auth\n```\n\n:::notes\nThis slide shows what Open Mercato ships with by default. The foundation modules give you multi-tenancy (directory), identity and permissions (auth), configuration (configs), dynamic data modeling (entities), and performance/indexing (query_index), plus operational modules like audit_logs, attachments, and API key support. On top of that are the core business domains\u2014customers, catalog, sales, and booking. Then there are UX and orchestration modules like dashboards, perspectives, workflows, and business rules. Finally, search and AI are included with the search and vector modules. The important part: these are all modules\u2014so you can disable, replace, or override them without forking the platform.\n:::\n",
  "# Extensibility (Developer Surface Area)\n\n## Extensible by design: Overlay + Modules + Generators + DI\n\n- Module-first architecture: every capability is a module (UI + API + data + DI + events), enabled/disabled in `src/modules.ts`\n- Overlay overrides (no forks): drop files into `src/modules/<module>/...` to override package behavior with the same relative path\n- Auto-discovery \u2192 generated registries: `npm run modules:prepare` scans enabled modules and emits glue (`generated/*`)\n- Multiple extension surfaces, same runtime:\n  - Pages: `frontend/*` \u2192 `/<path>`, `backend/*` \u2192 `/backend/<path>`\n  - API: `api/<method>/<path>.ts` \u2192 `/api/<path>` (each route exports `openApi`)\n  - Data: `data/entities.ts`, `data/extensions.ts` (links/extensions)\n  - Behavior: `di.ts`, `subscribers`, `workers`, `cli.ts`\n- Composable UI via injection widgets: extend screens through slots\n- Runtime schema extensibility: custom entities/fields via `ce.ts` + Entities module (EAV)\n- Search extensibility: per-module `search.ts` config (fulltext/vector/token presenters)\n\n```mermaid\nflowchart TD\n  Dev[\"Developer adds or overrides code<br/>src/modules/<module>/...<br/>or packages/<pkg>/src/modules/<module>\"] --> Gen[\"modules:prepare<br/>auto-discovery + merge overlays\"]\n  Gen --> Reg[\"Generated registries<br/>modules.generated.ts<br/>entities.generated.ts<br/>di.generated.ts<br/>widgets/search registries\"]\n\n  Reg --> Next[\"Next.js App Router<br/>frontend + backend pages\"]\n  Reg --> Api[\"Catch-all API router<br/>/app/api/[...slug]\"]\n  Reg --> Di[\"Awilix DI container<br/>module di.ts registrars\"]\n\n  Di --> Services[\"Services / Query Engine / Data Engine\"]\n  Services --> Db[(PostgreSQL)]\n\n  Di --> Events[\"Event bus\"]\n  Events --> Subs[\"subscribers/*.ts<br/>event-driven extensions\"]\n  Di --> Workers[\"workers/*.ts<br/>queue-driven extensions\"]\n\n  Next --> Widgets[\"Injection widgets<br/>extend screens via slots\"]\n  Api --> OpenAPI[\"openApi exports<br/>OpenAPI + Markdown docs\"]\n  Reg --> Search[\"search.ts configs<br/>vector/fulltext/tokens presenters\"]\n```\n\n:::notes\nOpen Mercato is designed to be extended without forking core packages. The main mechanism is the module system, plus an overlay: anything you put in src/modules/<module> overrides the package module file with the same path. At build time, modules:prepare scans enabled modules from modules.ts, merges overrides, and generates registries that drive routing, APIs, DI, entities, widgets, and search configs. From there, extension points are consistent: add pages under frontend/ or backend/, add APIs under api/<method>/... (and always export openApi so docs stay automatic), register services via di.ts, react to domain events via subscribers, and run async jobs via workers. For UI composition, injection widgets let modules extend existing screens through stable slots instead of tight coupling. And for data model evolution, custom entities + fields via ce.ts enable runtime schemas while still flowing through the same CRUD / indexing / search patterns.\n:::\n",
  "# Security Model \u2014 RBAC, ACLs, and Field-Level Encryption\n\n## RBAC + ACLs (who can do what, where)\n\n- Two-layer RBAC with role bundles + user overrides\n- Features are the unit of permission\n- Declared per module in `src/modules/<module>/acl.ts`\n- Naming: `<module>.<action>` (e.g. `auth.users.edit`, `booking.manage_resources`)\n- Enforcement:\n  - Declarative guards: `requireAuth`, `requireRoles`, `requireFeatures`\n  - Imperative checks: `rbacService.userHasAllFeatures(userId, features, { tenantId, organizationId })`\n- Tenant safety: `tenantId` + `organizationId`, optional org visibility, super admin override\n\n## Field-level encryption (protect data at rest)\n\n- Tenant-scoped encryption with per-tenant DEKs\n- Vault KMS (`VAULT_ADDR`, `VAULT_TOKEN`, `VAULT_KV_PATH`) or fallback key\n- Feature flag: `TENANT_DATA_ENCRYPTION=yes|no`\n- Encryption maps define protected fields (`encryptionDefaults.ts`)\n- Admin UI can toggle encrypted fields per entity\n- Custom fields (EAV) can be encrypted too\n- Deterministic lookups use hash columns (e.g. `email_hash`)\n- Rotation/backfill supported via CLI\n- For unsafe relations, use `findWithDecryption`\n\n```mermaid\nflowchart TD\n  U[User] -->|request| APP[Next.js page and API handler]\n\n  APP --> AUTH[Auth context<br/>tenantId + organizationId]\n  AUTH --> RBAC[RBAC enforcement<br/>requireAuth, roles, features<br/>+ rbacService checks]\n\n  RBAC -->|allowed| SVC[Module services<br/>DI container]\n  RBAC -->|denied| DENY[401 or 403]\n\n  SVC --> ORM[MikroORM + encryption hooks]\n  ORM --> DB[(PostgreSQL)]\n\n  subgraph ACLS[Permissions model]\n    F[Module features<br/>src/modules/*/acl.ts] --> META[Route and page metadata<br/>requireFeatures]\n    ROLE[Roles = feature bundles] --> RBAC\n    USERACL[User overrides<br/>grant or revoke] --> RBAC\n  end\n\n  subgraph ENCRYPT[Field-level encryption]\n    MAP[Encryption maps<br/>defaults + admin UI] --> ORM\n    KMS[Vault KMS or fallback key] --> ORM\n    HASH[Optional hash fields<br/>email_hash] --> DB\n  end\n\n  META --> RBAC\n```\n\n:::notes\nOpen Mercato security has two complementary layers. First is RBAC with feature flags: modules declare their capabilities as static feature strings in acl.ts, then pages and APIs declare requireAuth, requireRoles, and requireFeatures. Roles bundle features, and user-level ACL overrides can fine-tune access without role explosion. Every check is scoped by tenantId and organizationId, so multi-tenant boundaries are enforced by default.\n\nSecond is tenant data encryption: selected columns (and even custom fields) are encrypted at rest with tenant-scoped keys\u2014preferably from Vault, with safe fallback modes for development. Where deterministic lookup is needed, we store a hash column (like email_hash) so the encrypted value stays protected but queries remain fast and reliable. Together, RBAC controls access while field-level encryption reduces blast radius if the database is ever exposed.\n:::\n",
  "# Open Mercato Architecture\n\n**Modular, auto-discovered, and multi-tenant by default.**\n\n- Modules live under `src/modules/<module>` with frontend, backend, API, data, and DI\n- Generators build registries so runtime bootstraps the right modules and entities\n- CRUD routes use commands, side effects, and indexing for consistent flows\n- Data is tenant scoped and safely extended via custom fields and links\n\n```mermaid\nflowchart LR\n  UI[Admin UI / Client] --> API[API Routes]\n  API --> CMD[Commands]\n  CMD --> QE[Query Engine]\n  CMD --> IDX[Index + Search]\n  QE --> DB[(PostgreSQL)]\n  IDX --> DB\n  CMD --> EVT[Events / Workers]\n```\n\n:::notes\nFocus on the single-system view: UI and API routes drive commands, commands own side effects, and data flows through the query engine and indexer. Emphasize that modules are isolated and discovered automatically.\n:::\n",
  "# Module Anatomy and Auto-Discovery\n\nModules are self-contained, with predictable entry points and naming.\n\n```text\nsrc/modules/<module>/\n  frontend/    -> /<path>\n  backend/     -> /backend/<path>\n  api/<method>/ -> /api/<path>\n  data/        -> entities, validators, extensions\n  widgets/     -> injection widgets\n  workers/     -> background jobs\n  subscribers/ -> event handlers\n```\n\n- Page metadata lives in `page.meta.ts` or `metadata` exports\n- API routes export `openApi` for docs and tooling\n- Registries are generated by `npm run modules:prepare`\n\n:::notes\nPoint out the discovery rules and how this keeps modules isomorphic. Call out that modules do not reach into each other directly and communicate through links, widgets, or events.\n:::\n",
  "# Request Flow and Commands\n\nEvery CRUD action is routed through a command and emits side effects.\n\n```mermaid\nsequenceDiagram\n  participant UI as UI\n  participant API as API Route\n  participant CMD as Command\n  participant QE as Query Engine\n  participant IDX as Indexer\n  participant DB as Database\n\n  UI->>API: POST /api/resource\n  API->>CMD: create/update/delete\n  CMD->>DB: write\n  CMD->>IDX: emit index event\n  CMD->>QE: read for response\n  QE->>DB: fetch with scope\n  API-->>UI: normalized payload\n```\n\n- Commands are undoable and track side effects\n- Indexing keeps search and list views fast\n- Query engine enforces tenant and org scope\n\n:::notes\nStress the command pattern as the source of truth. The query engine reads data with scope, and indexing keeps lists, search, and widgets responsive.\n:::\n",
  "# Data Model and Extensibility\n\nEntities are per-module, with custom fields and links for cross-module data.\n\n```mermaid\nerDiagram\n  TENANTS ||--o{ ORGANIZATIONS : scopes\n  ORGANIZATIONS ||--o{ CORE_ENTITY : owns\n  CORE_ENTITY ||--o{ CUSTOM_FIELD_VALUE : has\n  CUSTOM_ENTITY ||--o{ CUSTOM_FIELD_VALUE : has\n  MODULE_LINK ||--o{ CORE_ENTITY : links\n```\n\n- No cross-module ORM relations; use foreign key IDs\n- Custom fields live in the entities module (EAV)\n- Extensions are declared via `data/extensions.ts`\n\n:::notes\nExplain how module isolation is maintained by design, and how custom fields and extension links let teams add data without rewriting core tables.\n:::\n"
];

      const state = {
        slides: [],
        current: 0,
      };

      const slideEl = document.getElementById("slide");
      const notesEl = document.getElementById("notes");
      const titleEl = document.getElementById("slide-title");
      const countEl = document.getElementById("count");
      const progressEl = document.getElementById("progress");
      const notesButton = document.getElementById("open-notes");
      const shareButton = document.getElementById("share-slide");
      const slideListEl = document.getElementById("slide-list");

      let notesWindow = null;

      const writeNotesWindow = () => {
        if (!notesWindow || notesWindow.closed) {
          return;
        }
        notesWindow.document.open();
        notesWindow.document.write(`<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Open Mercato Architecture â€“ Notes</title>
    <style>
      body {
        font-family: "Space Grotesk", system-ui, sans-serif;
        margin: 0;
        background: #0f1a1f;
        color: #eef6f8;
        padding: 24px;
      }
      h1 {
        font-size: 1.2rem;
        margin: 0 0 16px;
      }
      .slide-title {
        color: #f1c76f;
        margin-bottom: 8px;
        font-weight: 600;
      }
      .notes {
        background: rgba(255, 255, 255, 0.06);
        border-radius: 16px;
        padding: 16px;
        line-height: 1.6;
      }
    </style>
  </head>
  <body>
    <h1>Presenter Notes</h1>
    <div class="slide-title" id="notes-title"></div>
    <div class="notes" id="notes-content">Loading notes...</div>
    <script>
      window.addEventListener("message", (event) => {
        if (!event.data || event.data.type !== "notes:update") return;
        const { title, notes } = event.data.payload;
        document.getElementById("notes-title").textContent = title || "Untitled slide";
        document.getElementById("notes-content").innerHTML = notes || "<p>No notes.</p>";
      });
    <\/script>
  </body>
</html>`);
        notesWindow.document.close();
      };

      const updateNotesWindow = (slide) => {
        if (!notesWindow || notesWindow.closed) {
          return;
        }
        notesWindow.postMessage(
          {
            type: "notes:update",
            payload: {
              title: slide.title || `Slide ${state.current + 1}`,
              notes: slide.notes ? renderMarkdown(slide.notes) : "<p>No notes.</p>",
            },
          },
          "*"
        );
      };

      const renderMarkdown = (markdown) => {
        if (!window.marked) {
          return "<p>Markdown parser not loaded.</p>";
        }
        return marked.parse(markdown);
      };

      const slugify = (value) =>
        value
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, "")
          .trim()
          .replace(/\s+/g, "-");

      const parseSlide = (raw) => {
        const notesMarker = ":::notes";
        const notesEnd = ":::\n";
        let content = raw;
        let notes = "";

        if (raw.includes(notesMarker)) {
          const parts = raw.split(notesMarker);
          content = parts[0].trim();
          const notesBlock = parts[1] || "";
          const notesParts = notesBlock.split(":::");
          notes = notesParts[0].trim();
        }

        return { content, notes };
      };

      const updateProgress = () => {
        const total = state.slides.length;
        const current = state.current + 1;
        countEl.textContent = `${current} / ${total}`;
        const pct = total ? (current / total) * 100 : 0;
        progressEl.style.width = `${pct}%`;
      };

      const renderSlideList = () => {
        if (!slideListEl) return;
        slideListEl.innerHTML = "";
        const title = document.createElement("h2");
        title.textContent = "Slides";
        const list = document.createElement("ul");
        state.slides.forEach((slide, index) => {
          const item = document.createElement("li");
          const button = document.createElement("button");
          button.type = "button";
          button.textContent = slide.title || `Slide ${index + 1}`;
          if (index === state.current) {
            button.classList.add("active");
          }
          button.addEventListener("click", () => goTo(index));
          item.appendChild(button);
          list.appendChild(item);
        });
        slideListEl.appendChild(title);
        slideListEl.appendChild(list);
      };

      const renderSlide = () => {
        const slide = state.slides[state.current];
        if (!slide) {
          slideEl.innerHTML = "<p>No slide loaded.</p>";
          return;
        }
        slideEl.innerHTML = renderMarkdown(slide.content);
        titleEl.textContent = slide.title || `Slide ${state.current + 1}`;
        notesEl.innerHTML = slide.notes ? renderMarkdown(slide.notes) : "<p>No notes.</p>";
        updateProgress();
        updateNotesWindow(slide);
        if (slide.slug) {
          history.replaceState(null, "", `#slide-${slide.slug}`);
        }
        renderSlideList();

        slideEl.querySelectorAll("a[href^=\"#slide-\"]").forEach((link) => {
          link.addEventListener("click", (event) => {
            event.preventDefault();
            const target = link.getAttribute("href").replace("#slide-", "");
            const index = state.slides.findIndex((item) => item.slug === target);
            if (index !== -1) {
              goTo(index);
            }
          });
        });

        if (window.mermaid) {
          mermaid.initialize({ startOnLoad: false, theme: "dark" });
          slideEl.querySelectorAll("pre code.language-mermaid").forEach((block) => {
            const container = document.createElement("div");
            container.className = "mermaid";
            container.textContent = block.textContent;
            block.parentElement.replaceWith(container);
          });
          mermaid.run({ nodes: slideEl.querySelectorAll(".mermaid") });
        }
      };

      const goTo = (index) => {
        const total = state.slides.length;
        if (!total) return;
        state.current = (index + total) % total;
        renderSlide();
      };

      const extractTitle = (markdown) => {
        const match = markdown.match(/^#\s+(.*)$/m);
        return match ? match[1].trim() : "";
      };

      const loadSlides = () => {
        state.slides = rawSlides.map((raw) => {
          const parsed = parseSlide(raw);
          const title = extractTitle(parsed.content);
          return {
            content: parsed.content,
            notes: parsed.notes,
            title,
            slug: title ? slugify(title) : "",
          };
        });
        const hash = window.location.hash.replace("#slide-", "");
        const initialIndex = hash
          ? state.slides.findIndex((slide) => slide.slug === hash)
          : 0;
        state.current = initialIndex >= 0 ? initialIndex : 0;
        renderSlide();
      };

      document.getElementById("prev").addEventListener("click", () => goTo(state.current - 1));
      document.getElementById("next").addEventListener("click", () => goTo(state.current + 1));

      window.addEventListener("keydown", (event) => {
        if (event.key === "ArrowLeft") {
          goTo(state.current - 1);
        }
        if (event.key === "ArrowRight") {
          goTo(state.current + 1);
        }
        if (event.key.toLowerCase() === "n") {
          notesEl.classList.toggle("visible");
        }
      });

      notesButton.addEventListener("click", () => {
        if (!notesWindow || notesWindow.closed) {
          notesWindow = window.open("", "presenter-notes", "width=480,height=720");
          writeNotesWindow();
        }
        const slide = state.slides[state.current];
        if (slide) {
          updateNotesWindow(slide);
        }
        notesWindow.focus();
      });

      shareButton.addEventListener("click", async () => {
        const slide = state.slides[state.current];
        const hash = slide && slide.slug ? `#slide-${slide.slug}` : "";
        const url = `${window.location.origin}${window.location.pathname}${hash}`;
        try {
          await navigator.clipboard.writeText(url);
          shareButton.textContent = "Copied";
          setTimeout(() => {
            shareButton.innerHTML = `
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 12a3 3 0 0 1 3-3h4"></path>
                <path d="M10 9l-2 2 2 2"></path>
                <path d="M17 12a3 3 0 0 1-3 3h-4"></path>
                <path d="M14 15l2-2-2-2"></path>
              </svg>
              Copy link
            `;
          }, 1200);
        } catch (error) {
          window.prompt("Copy this link:", url);
        }
      });

      loadSlides();
    </script>
  </body>
</html>
