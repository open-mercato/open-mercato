#!/usr/bin/env tsx
import fs from 'node:fs'
import path from 'node:path'
import crypto from 'node:crypto'
import { loadEnabledModules, moduleFsRoots, moduleImportBase } from './shared/modules-config'

const outFile = path.resolve('generated/entities.generated.ts')
const checksumFile = path.resolve('generated/entities.generated.checksum')

function toVar(s: string) {
  return s.replace(/[^a-zA-Z0-9_]/g, '_')
}

function calculateChecksum(content: string): string {
  return crypto.createHash('md5').update(content).digest('hex')
}

function scan() {
  const mods = loadEnabledModules()
const imports: string[] = []
const entitySources: Array<{ importName: string; moduleId: string }> = []
let n = 0
for (const entry of mods) {
  const modId = entry.id
    const roots = moduleFsRoots(entry)
    const imp = moduleImportBase(entry)
    // prefer app override data/, fallback to core data/, then legacy db/
    const appData = path.join(roots.appBase, 'data')
    const pkgData = path.join(roots.pkgBase, 'data')
    const appDb = path.join(roots.appBase, 'db')
    const pkgDb = path.join(roots.pkgBase, 'db')
    const bases = [appData, pkgData, appDb, pkgDb]
    const candidates = ['entities.override.ts', 'entities.ts', 'schema.ts']
    let found: { base: string; file: string } | null = null
    for (const base of bases) {
      for (const f of candidates) {
        const p = path.join(base, f)
        if (fs.existsSync(p)) { found = { base, file: f }; break }
      }
      if (found) break
    }
    if (!found) continue
    const importName = `E_${toVar(modId)}_${n++}`
    const sub = path.basename(found.base) // 'data' or 'db'
    const fromApp = found.base.startsWith(roots.appBase)
    const baseImport = fromApp ? imp.appBase : imp.pkgBase
    const relImport = `${baseImport}/${sub}/${found.file.replace(/\.ts$/, '')}`
    imports.push(`import * as ${importName} from '${relImport}'`)
    entitySources.push({ importName, moduleId: modId })
  }
  const output = `// AUTO-GENERATED by scripts/generate-module-entities.ts
${imports.join('\n')}

function enhanceEntities(namespace: Record<string, unknown>, moduleId: string): any[] {
  return Object.entries(namespace)
    .filter(([, value]) => typeof value === 'function')
    .map(([exportName, value]) => {
      const entity = value as { entityName?: string }
      if (entity && typeof entity === 'function' && !Object.prototype.hasOwnProperty.call(entity, 'entityName')) {
        Object.defineProperty(entity, 'entityName', {
          value: \`\${moduleId}.\${exportName}\`,
          configurable: true,
          enumerable: false,
          writable: false,
        })
      }
      return entity
    })
}

export const entities = [
  ${entitySources.map(({ importName, moduleId }) => `...enhanceEntities(${importName}, '${moduleId}')`).join(',\n  ')}
]
`
  
  // Check if content has changed
  const newChecksum = calculateChecksum(output)
  let shouldWrite = true
  
  if (fs.existsSync(checksumFile)) {
    const existingChecksum = fs.readFileSync(checksumFile, 'utf8').trim()
    if (existingChecksum === newChecksum) {
      shouldWrite = false
    }
  }
  
  if (shouldWrite) {
    fs.writeFileSync(outFile, output)
    fs.writeFileSync(checksumFile, newChecksum)
    console.log('Generated', path.relative(process.cwd(), outFile))
  }
}

scan()
