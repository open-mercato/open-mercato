#!/usr/bin/env tsx
import { mkdir, readFile, writeFile } from 'node:fs/promises'
import path from 'node:path'
import { fileURLToPath, pathToFileURL } from 'node:url'
import {
  astToString,
  COMMENT_HEADER,
  resolveRef,
  scanDiscriminators,
  transformSchema,
  type GlobalContext,
  type OpenAPI3,
  type ServerObject,
  type OpenAPITSOptions,
} from 'openapi-typescript'
import { buildOpenApiDocument, sanitizeOpenApiDocument } from '@open-mercato/shared/lib/openapi'
import { modules } from '../generated/modules.generated'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const repoRoot = path.resolve(__dirname, '..')
const clientRoot = path.join(repoRoot, 'packages/client')
const generatedDir = path.join(clientRoot, 'src/generated')
const typesOutputPath = path.join(generatedDir, 'openapi.types.ts')

async function ensureDir(dir: string) {
  await mkdir(dir, { recursive: true })
}

async function writeIfChanged(filePath: string, content: string) {
  try {
    const existing = await readFile(filePath, 'utf8')
    if (existing === content) return false
  } catch {
    // Ignore missing file
  }
  await writeFile(filePath, content, 'utf8')
  return true
}

function resolveBaseUrl(): string {
  return (
    process.env.OPEN_MERCATO_API_BASE_URL ||
    process.env.NEXT_PUBLIC_API_BASE_URL ||
    process.env.APP_URL ||
    'http://localhost:3000/api'
  )
}

function coerceToOpenAPI3(document: ReturnType<typeof sanitizeOpenApiDocument>): OpenAPI3 {
  const servers = (document.servers ?? []).map((server: ServerObject) => ({
    url: server.url,
    description: server.description,
    variables: server.variables ?? {},
  }))
  return { ...(document as Record<string, unknown>), servers } as OpenAPI3
}

async function main() {
  await ensureDir(generatedDir)
  const rawDoc = buildOpenApiDocument(modules, {
    title: 'Open Mercato API',
    version: '1.0.0',
    description: 'Auto-generated OpenAPI document for all enabled modules.',
    servers: [{ url: resolveBaseUrl(), description: 'Default environment' }],
    baseUrlForExamples: resolveBaseUrl(),
    defaultSecurity: ['bearerAuth'],
  })
  const doc = coerceToOpenAPI3(sanitizeOpenApiDocument(rawDoc))

  const header = '// AUTO-GENERATED by scripts/generate-api-client.ts -- DO NOT EDIT\n'
  const tsOptions: OpenAPITSOptions = {
    alphabetize: true,
    defaultNonNullable: false,
    arrayLength: false,
  }
  const ctx: GlobalContext = {
    additionalProperties: tsOptions.additionalProperties ?? false,
    alphabetize: tsOptions.alphabetize ?? false,
    arrayLength: tsOptions.arrayLength ?? false,
    defaultNonNullable: tsOptions.defaultNonNullable ?? true,
    discriminators: scanDiscriminators(doc, tsOptions),
    emptyObjectsUnknown: tsOptions.emptyObjectsUnknown ?? false,
    enum: tsOptions.enum ?? false,
    enumValues: tsOptions.enumValues ?? false,
    dedupeEnums: tsOptions.dedupeEnums ?? false,
    excludeDeprecated: tsOptions.excludeDeprecated ?? false,
    exportType: tsOptions.exportType ?? false,
    immutable: tsOptions.immutable ?? false,
    rootTypes: tsOptions.rootTypes ?? false,
    rootTypesNoSchemaPrefix: tsOptions.rootTypesNoSchemaPrefix ?? false,
    injectFooter: [],
    pathParamsAsTypes: tsOptions.pathParamsAsTypes ?? false,
    postTransform: typeof tsOptions.postTransform === 'function' ? tsOptions.postTransform : undefined,
    propertiesRequiredByDefault: tsOptions.propertiesRequiredByDefault ?? false,
    redoc: undefined as any,
    silent: tsOptions.silent ?? false,
    inject: tsOptions.inject,
    transform: typeof tsOptions.transform === 'function' ? tsOptions.transform : undefined,
    transformProperty: typeof tsOptions.transformProperty === 'function' ? tsOptions.transformProperty : undefined,
    makePathsEnum: tsOptions.makePathsEnum ?? false,
    generatePathParams: tsOptions.generatePathParams ?? false,
    resolve($ref: string) {
      return resolveRef(doc, $ref, { silent: tsOptions.silent ?? false })
    },
  }
  const ast = transformSchema(doc, ctx)
  const printed = astToString(ast)
  const typeSerialized = `${header}${COMMENT_HEADER}${printed.trimEnd()}\n`
  const wroteTypes = await writeIfChanged(typesOutputPath, typeSerialized)

  if (wroteTypes) {
    console.log('✅ Generated Open API artifacts')
  } else {
    console.log('ℹ️ Open API artifacts already up to date')
  }
}

if (pathToFileURL(process.argv[1] ?? '').href === import.meta.url) {
  main().catch((error) => {
    console.error('[api-client] Failed to generate client artifacts:', error)
    process.exitCode = 1
  })
}
